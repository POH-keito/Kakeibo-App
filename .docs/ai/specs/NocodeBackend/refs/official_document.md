# NoCodeBackend V2 公式チュートリアル

**出典:** [NoCodeBackend 公式ドキュメント](https://docs.nocodebackend.com/)  
**最終更新:** 2025 年

---

## 概要

このガイドでは、NoCodeBackend V2 の新しい UI を紹介し、サーバーコードを一行も書かずに、数分で完全に機能するバックエンド（データベース、API エンドポイント、ドキュメント、AI によるスキーマ生成）を構築する方法を説明します。

---

## Step 1: NoCodeBackend V2 の概要

V2 リリースでは、UX と UI を全面的に再設計し、より滑らかで洗練されたプロフェッショナルなシステムになりました。V2 の主な改善点は以下の 3 つです：

### 主な改善点

1. **パフォーマンスの向上**

   - スキーマ作成、エンドポイント生成、ドキュメント生成などの日常的な操作がほぼ瞬時に完了

2. **コア機能の強化**

   - より強力なスキーマ作成機能
   - 機密フィールドのセキュリティ強化
   - 組み込みの Join サポート

3. **AI/エージェント自動化**
   - AI（エージェント）ビルダーが自然言語プロンプトからデータベースとエンドポイント全体を生成可能

V2 は、プロジェクトから反復的なバックエンド作業を削減し、チームが製品とフロントエンドロジックに集中できるように設計されています。

---

## Step 2: Quick Create でデータベースを作成

最も高速な方法である **Quick Create** から始めます。これは、必要なテーブルとフィールドが既に分かっている場合に最適です。

### ワークフロー

1. **データベースを作成して名前を付ける**

   - 新しいデータベースを開始し、名前を付けます

2. **テーブルとカラムを追加**

   - 同じ操作で複数のテーブルとカラムを追加可能（UI は複数テーブル/複数カラムの作成をサポート）

3. **API エンドポイントとドキュメントを生成**

   - テーブル/カラムを定義すると、システムが自動的に REST エンドポイントと Swagger 風のドキュメントを生成

4. **シークレットキーを生成**
   - 生成された API を安全に呼び出すためのシークレットキーを作成

### 改善点

以前のインターフェースでは、初期セットアップ時に 1 つのテーブルと 1 つのカラムしか作成できませんでした。この制限は解消され、同じ操作で複数のテーブルと多くのカラムを追加できるようになりました。これは大きな生産性向上です。

### 例

データベース名「11 September」を作成し、2 つのテーブルを定義：

- **users テーブル**: `name` (varchar), `email` (varchar), `password` (password 型)
- **books テーブル**: `book_name` (varchar), `price` (int)

「Create」をクリックすると、システムがデータベースを構築し、すべてのテーブルに対して RESTful エンドポイントを自動生成します。スキーマからエンドポイント、ドキュメントまでの全プロセスが 1 分以内に生成されます。

### 自動生成されるもの

- バックエンドに作成されたデータベーステーブルとカラム
- 各テーブルに対する CRUD 操作の REST エンドポイント（POST、GET、PUT、DELETE）
- 即座にテストと統合が可能な自動生成 API ドキュメント
- 安全な API アクセスに使用されるシークレットキー

これらにより、React、Webflow、モバイルアプリ、HTTP 呼び出しが可能な静的サイトなど、あらゆるフロントエンド技術スタックとのバックエンド統合の摩擦が軽減されます。

---

## Step 3: API ドキュメントの理解とエンドポイントのテスト

バックエンドが作成されると、「API Documentation」リンクをクリックして Swagger 風のインターフェースを開きます。ドキュメントは各テーブルをパスとして表示し、各テーブルで利用可能なメソッドを一覧表示します。

### REST メソッドの例（books テーブル）

- `POST /books` — 新しい書籍レコードを作成
- `GET /books` — オプションのクエリフィルターを使用してレコードを読み取り
- `PUT /books/{id}` — ID で書籍を更新
- `DELETE /books/{id}` — ID で書籍を削除

### ドキュメントの機能

ドキュメントには、フロントエンドや統合スクリプトにコピーできる準備済みの cURL スニペットとヘッダーが提供されます。以下が含まれます：

- エンドポイント URL
- Authorization ヘッダー（Bearer トークン）
- JSON リクエストボディのスケルトン
- レスポンス例

### 実践的なヒント

cURL スニペットをターミナルや Postman などのツールにコピーして、動作を素早く検証できます。その後、フロントエンドのフォーム送信ハンドラーに同じ呼び出しを実装します。ドキュメントにより、フォームフィールドをエンドポイントに接続する際の推測が不要になります。

### クエリフィルターの例

読み取りエンドポイントはクエリフィルターをサポートしているため、`price > 99` や `price < 500` などの条件でレコードを取得できます。すべてバックエンドコードを書かずに実現可能です。

---

## Step 4: Password 型で機密データを保護

最も重要なセキュリティ改善の一つは、ネイティブの **password カラム型**です。

### Password 型の動作

カラムを password に設定すると：

- 書き込み時に安全なアルゴリズム（bcrypt）を使用して値がハッシュ化される
- レスポンスにはハッシュ値が返され、平文は返されない
- 元の値は API 経由で取得できない — ハッシュのみが保存される

### bcrypt を使用する理由

bcrypt は、パスワード保存用に設計された実績のあるハッシュアルゴリズムです。ブルートフォース攻撃を緩和するために意図的に遅く設計されており、ソルトが含まれています。プラットフォームがデフォルトでハッシュ化を処理するため、フロントエンドやバックエンドコードでハッシュ化フローを実装する必要はありません。

### Password 型を使用すべき場合

- ユーザーアカウントのパスワード
- ワンタイムパスワード（OTP）
- シークレットトークンや API キー
- 平文で表示すべきでない機密文字列データ

### 注意事項

そのカラムでクエリやソートが必要な場合は、password 型の使用を避けてください。ハッシュは不透明で、意味のある方法で検索できません。機密性のためだけに使用してください。

---

## Step 5: Join の作成 — 複数のテーブルを 1 つのエンドポイントに統合

関連するテーブルの統合ビューが必要な場合、Join は不可欠です。NoCodeBackend V2 は、Join を作成する 3 つの方法をサポートしています：

### Join の作成方法

1. **Create Join UI**: 一般的な Join 用のビジュアルエディター
2. **SQL Query モード**: SQL を直接記述することを好む開発者向け
3. **AI 生成 Join**: 要件を記述すると、システムが Join を構築

### 例

books と users をマージし、1 つのエンドポイントが書籍名、価格、ユーザー名、ユーザーメールアドレスを返すようにします。Join を作成後、API ドキュメントを更新すると、新しい Join パスが利用可能になります。

### トラブルシューティング: データが返されない場合

Join エンドポイントが最初にデータを返さなかった場合、理由は単純です：関連テーブルの ID 値が一致していませんでした。Join がデータを返すには、Join キーの値が一致している必要があります。

**解決策**: 新しいユーザー（ID 3）を作成し、book ID 3 と user ID 3 をマッチさせて統合レコードを生成しました。

### 設計上の注意

本番スキーマでは、テーブルを関連付けるために明示的な外部キーを使用してください（例：`books.owner_id` が `users.id` を参照）。これにより、偶発的な不一致を避け、Join を予測可能にできます。プラットフォームは、スキーマエディターを通じてそのような参照の作成をサポートしています。

---

## Step 6: AI Builder の使用 — AI によるデータベース生成

AI Builder は、自然言語プロンプトからデータベースとエンドポイント全体を作成できる強力な生産性ツールです。

### 使用例

プロンプト例：

> "I need a database called movies with tables for Hollywood and Bollywood. Each table should have columns: movie_name, movie_release_date, movie_genre. movie_genre should be a dropdown with options Action, Sci-Fi, Romance."

「Send Request」をクリックすると、バックグラウンドでエージェントパイプラインがトリガーされ、複数の LLM モデル（それぞれが特定のタスクに特化）を使用して、スキーマを構築し、ドロップダウンオプションを設定し、エンドポイントを生成し、ドキュメントを更新します。AI（エージェント）呼び出しは、すべてを一度に調整するため、すぐに完全に使用可能なバックエンドを取得できます。

### AI Builder を使用すべき場合

- 迅速なプロトタイピング
- 口頭でのアイデアはあるが、正式なスキーマがない場合
- LMS、映画カタログ、在庫などの機能をブートストラップしたい場合
- 自然言語で要件を記述することを好む非技術的な創業者

### エージェント呼び出しについて

AI 呼び出しは、1 回の呼び出しで複数のアクション（スキーマ作成、エンドポイント生成、ドキュメント更新、オプションでシードデータ）を実行するため、エージェント呼び出しと呼ばれます。これらの呼び出しは非常に有用ですが、レビューが必要です — AI 生成スキーマは、本番環境の制約（インデックス、外部キー、バリデーションルール）に対して調整が必要な場合があります。

---

## Step 7: フロントエンドとの統合 — 実践例

各エンドポイントは標準的な REST エンドポイントであるため、統合は簡単です。

### 典型的なフロントエンドフロー

1. **フォームを作成してフィールドをマッピング**

   - POST エンドポイントに必要な JSON プロパティにフィールドをマッピングしたフォームを作成

2. **送信と認証**

   - フォーム送信時に、シークレットキーを Authorization ヘッダーに設定して生成されたエンドポイントに HTTP POST リクエストを送信

3. **GET でリストを生成**

   - 検索とページネーションのためのクエリフィルターを使用して、GET エンドポイントでリストとダッシュボードを生成

4. **編集と削除**
   - レコードの編集には PUT を、削除アクションには DELETE を使用

### 例: React フォームで書籍を作成

- **フィールド**: `book_name`, `price`
- **送信時**: Authorization ヘッダーとともに `/books` に POST リクエスト、ボディ: `{ "book_name": "XYZ", "price": 99 }`
- **成功時**: ダッシュボードにリダイレクトし、`GET /books` を呼び出してリストを更新

### クエリフィルターとダッシュボード

GET エンドポイントはクエリフィルターをサポートしているため、ダッシュボードはサーバーロジックなしで動的ビューを表示できます。

**フィルター例**:

- `price > 100`
- `created_at < 2024-01-01`
- `name contains "Harry"`

フロントエンドからフィルターパラメータを使用して GET エンドポイントを呼び出し、ページネーション付きリストをレンダリングできます。これにより、フロントエンドがシンプルになり、バックエンドフィルタリングロジックを手動で構築する必要がなくなります。

---

## Step 8: チーム機能、カスタムドメイン、アカウント制限

NoCodeBackend V2 には、コラボレーション機能とプランレベルのコントロールが含まれています：

### チーム機能

- **ユーザー招待**: プランに応じて、チームメンバーを招待してデータベースを作成または編集可能。招待人数と権限はサブスクリプションレベルによって異なります
- **Shared with me**: 招待者が作成したデータベースを表示し、作成者でフィルタリングする専用タブ
- **カスタムドメイン**: 対象プランでは、`api.nocodebackend.com` の代わりに独自のドメイン/サブドメインで API ドキュメントを提供可能
- **クォータ割り当て**: データベースとリソースのクォータは、アカウントプラン全体から取得されます

### カスタムドメインの利点

カスタムドメインは、ブランディングや内部開発者ポータルにドキュメントを埋め込む場合に有用です。CNAME を設定し、ドキュメントを独自の製品ドメインに属するかのように提供できます。

---

## Step 9: プラン、クレジット、エージェント呼び出し

理解すべき 2 つの重要な収益化項目：

### データベースクレジットと一括購入

起動時、追加のデータベースや機能は一括購入のクレジットとして購入できます。これらのクレジットは、アカウントがアクティブな限り有効期限がありません。

### エージェント AI クレジット

AI 呼び出しは、複数のステップを調整するため、単一の AI API 呼び出しよりも強力です。これらはクレジットとして販売され、現在は一括購入として提供されています。価格モデルは、将来的に月額または年額サブスクリプションに移行する可能性があります。

### 使用計画

プロトタイピングでは、一括価格でエージェントクレジットを一括購入し、迅速な生成を実験できます。本番環境や長期使用では、適切に予算を組めるよう、サブスクリプションの変更に注意してください。

---

## Step 10: ベストプラクティスとヒント

NoCodeBackend を最大限に活用するために、以下を推奨します：

### 推奨事項

1. **スキーマを慎重に設計**

   - 大規模なデータセットを保存するテーブルについては、外部キーとインデックスを検討

2. **機密性のために Password 型を使用**

   - 機密データにはハッシュ値のみを保存し、平文のシークレットを保存しようとしない

3. **ダッシュボードに Join を活用**

   - 非正規化されたコピーを作成する代わりに、Join エンドポイントを使用して統合ビューを提示

4. **フロントエンドでもデータを検証**

   - バックエンドが有効な形式を受け入れる一方で、クライアント側の検証は UX を向上させ、不正なリクエストを減らす

5. **生成されたスキーマを監査**

   - AI は高速ですが、生成されたテーブルとフィールドをレビューし、ビジネス要件と一致していることを確認

6. **API キーを秘密に保つ**
   - アカウントシークレットを公開クライアント側コードに直接埋め込まない。公開露出がリスクの場合はサーバーサイドプロキシを使用するか、キーを頻繁にローテーション

### 本番システム向け

本番システムを構築するチームは、NoCodeBackend をバックエンド即サービス（BaaS）として扱い、標準的な運用プラクティス（監視、バックアップ、アクセス制御管理）に従ってください。

---

## Step 11: 一般的な問題のトラブルシューティング

遭遇する可能性のある一般的な問題とその解決方法：

### よくある問題と解決策

1. **Join でデータが返されない**

   - Join キーが一致し、参照されているレコードが存在することを確認

2. **認証エラー**

   - Authorization ヘッダーに正しいシークレットキーが含まれ、キーが再生成または取り消されていないことを確認

3. **カラムが見つからない、またはフィールド名が間違っている**

   - 正確な JSON プロパティ名についてはドキュメントを確認 — AI 生成名は自然言語とわずかに異なる場合があり、スキーマエディターで編集可能

4. **レート制限またはクレジット不足**

   - ダッシュボードでプランとクレジット残高を確認し、必要に応じて追加のクレジットを購入

5. **Password フィールドが表示される**
   - Password フィールドに平文が表示される場合は、サポートに連絡し、すぐに認証情報をローテーション。設計上、平文が表示されることはありません

---

## よくある質問（FAQ）

### Q: NoCodeBackend を使用するためにバックエンドコードを書く必要がありますか？

**A:** いいえ。主な価値提案は、サーバーサイドコーディングなしでデータベース、エンドポイント、ドキュメントを作成できることです。複雑なカスタムロジックには、Azure、Vercel、Cloudflare などのサーバーレス関数を提供するサードパーティサービスを使用することを好む場合もありますが、多くのアプリは生成された API のみで完全に動作します。

### Q: 認証はどのように機能しますか？

**A:** NoCodeBackend によって生成された API は、認証にシークレットキーを使用します。シークレットキーは、Authorization ヘッダーでベアラートークンとして渡されます。本番環境では、公開クライアント側コードでキーを露出させないように、サーバーサイドプロキシまたはシークレット管理を使用することを推奨します。

### Q: AI Builder とエージェント呼び出しとは何ですか？

**A:** AI Builder はエージェント AI ワークフローを使用します。単一のモデルがすべてを行うのではなく、複数の専門エージェント（LLM とツール）が調整して、1 回の調整された操作でスキーマ、エンドポイント、ドキュメント、オプションでシードデータを作成します。これはエージェント AI 呼び出しと呼ばれ、単一の AI 呼び出しよりも強力です。

### Q: 独自のドメインで API ドキュメントを実行できますか？

**A:** はい。カスタムドメインサポートは対象プランで利用可能で、ブランディングや内部アクセスのために独自のドメインまたはサブドメインで API ドキュメントをホストできます。

### Q: クレジットと価格はどのように構成されていますか？

**A:** 起動時、追加のデータベースと AI エージェント呼び出しは、アカウントがアクティブな限り有効期限がない一括購入クレジットとして購入できます。プラットフォームは、将来的に継続的な使用に対して月額/年額サブスクリプションモデルに移行する予定です。現在の詳細については、ダッシュボードの「Plans & Limits」セクションを確認してください。

### Q: 生の SQL を使用できますか？

**A:** はい。SQL に精通している開発者向けに、NoCodeBackend はカスタムクエリと複雑な Join を可能にする SQL クエリモードを公開しています。これは、ビジュアル Join ビルダーを超えた高度な操作が必要なシナリオに有用です。

### Q: チームメンバーを招待してロールを管理するにはどうすればよいですか？

**A:** ダッシュボードには、プラン制限によって制御される「Invite Users」機能が含まれています。招待されたユーザーはデータベースを作成または共有でき、その活動は「Shared with me」タブで確認できます。プランレベルの設定を使用して、クォータと権限を管理します。

---

## まとめ — より少ない摩擦でより速く起動

NoCodeBackend V2 は、通常チームの速度を低下させる反復的なバックエンドタスク（データベースの作成、エンドポイントの生成、フィールドの保護、明確なドキュメントの公開）を自動化することで、製品開発を加速するように構築されています。手動のビジュアルアプローチを好む場合でも、要件を平易な英語で記述して AI にスキーマを生成させる場合でも、プラットフォームは両方をサポートします。エージェント AI Builder 呼び出しは、新機能を迅速にブートストラップするのに特に強力です。

NoCodeBackend でプロトタイプを作成し、アイデアを検証し、より速く反復することを推奨します。本番システムでは、標準的なベストプラクティスに従ってください：AI 生成スキーマをレビューし、機密データに Password フィールドを使用し、API キーを制御し、ロールを慎重に管理します。

---

## さらなる学習と次のステップ

より深く掘り下げたい場合は、NoCodeBackend アカウントで次のステップを試してください：

1. 小さなプロトタイププロンプトで AI Builder を実験し、生成されたスキーマをレビュー
2. Quick Create でテストデータベースを作成し、API ドキュメントを開いて cURL スニペットを Postman にコピー
3. サンプル users テーブルで Password カラムを有効にし、bcrypt ハッシュ化の動作を観察
4. 2 つの小さなテーブル間で Join を設定し、一致する外部キーを確認して Join 結果を確認

問題が発生した場合は、ダッシュボードのサポートチャネルを使用するか、アカウントから利用可能なプラットフォームドキュメントを参照してください。これらのリソースは、アカウント固有のヘルプを取得し、各ステップのスクリーンショットやビデオチュートリアルを表示する最も迅速な方法です。

---

**参考リンク:** [NoCodeBackend 公式ドキュメント](https://docs.nocodebackend.com/)
